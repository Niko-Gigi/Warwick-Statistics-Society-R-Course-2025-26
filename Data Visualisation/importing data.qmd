---
title: "Data Import and Preparation in R"
format: 
  html:
    fig-width: 10
    fig-height: 5
    code-fold: show
    code-tools: true
    toc: true
    code-copy: true
    number_sections: true
---

# Introduction

Before you can visualize or analyze data, you need to get it into R and prepare it properly. This step is crucial—even the most sophisticated analysis will fail if your data isn't prepared correctly. Think of it like preparing ingredients before cooking: skipping or rushing this step will affect everything that follows.

In this guide, we'll learn how to import data from various file formats and clean it for analysis. We'll use the `palmerpenguins` dataset for most examples, which contains measurements of penguins from Antarctica.

# Importing Data into R

R can read data from almost any file format: text files, CSV files, Excel spreadsheets, and even specialized statistical software formats.

## CSV and Text Files

The `readr` package provides efficient functions for importing text-based data:

```{r}
#| eval: false
library(readr)

# Import from a CSV file (comma-separated values)
penguins_data <- read_csv("penguins.csv")

# Import from a tab-delimited text file
penguins_data <- read_tsv("penguins.txt")
```

These functions assume that:
- The first row contains column names
- Values are separated by commas (CSV) or tabs (TSV)
- Missing data appears as blank cells

Here's what the first few lines of a CSV file look like:

```
species,island,bill_length_mm,bill_depth_mm,flipper_length_mm,body_mass_g,sex
Adelie,Torgersen,39.1,18.7,181,3750,male
Adelie,Torgersen,39.5,17.4,186,3800,female
Adelie,Torgersen,40.3,18.0,195,3250,female
```

**Tip**: For more options (like different delimiters or handling special cases), check the help documentation with `?read_csv`.

## Excel Files

The `readxl` package handles Excel workbooks (both .xls and .xlsx):

```{r}
#| eval: false
library(readxl)

# Import from an Excel file
penguins_data <- read_excel("penguins.xlsx", sheet = 1)

# Import from a specific worksheet by name
penguins_data <- read_excel("penguins.xlsx", sheet = "Measurements")
```

Since Excel files can have multiple worksheets, use the `sheet` option to specify which one you want. The default is the first sheet.

## Files from Other Statistical Software

The `haven` package lets you import data from other statistical programs without needing those programs installed:

```{r}
#| eval: false
library(haven)

# Import from Stata
data_stata <- read_dta("data.dta")

# Import from SPSS
data_spss <- read_sav("data.sav")

# Import from SAS
data_sas <- read_sas("data.sas7bdat")
```

# Cleaning and Transforming Data

Once your data is in R, you'll usually need to clean and reshape it. The `dplyr` and `tidyr` packages are your main tools for this task.

Let's load the penguins dataset for our examples:

```{r}
#| message: false
library(dplyr)
library(palmerpenguins)

# View the structure of our data
glimpse(penguins)
```

## Selecting Variables (Columns)

Use `select()` to keep only the columns you need:

```{r}
# Keep just species, island, and body mass
penguin_subset <- select(penguins, species, island, body_mass_g)

head(penguin_subset)
```

```{r}
# Keep species and all columns from bill_length_mm through body_mass_g
penguin_subset <- select(penguins, species, bill_length_mm:body_mass_g)

head(penguin_subset)
```

```{r}
# Keep everything except year and sex
penguin_subset <- select(penguins, -year, -sex)

head(penguin_subset)
```

## Filtering Observations (Rows)

Use `filter()` to keep only rows that meet certain conditions. You can combine conditions with `&` (AND) and `|` (OR):

```{r}
# Select only Adelie penguins
adelie_only <- filter(penguins, species == "Adelie")

head(adelie_only)
```

```{r}
# Select Adelie penguins from Torgersen island
adelie_torgersen <- filter(penguins, 
                            species == "Adelie" & 
                            island == "Torgersen")

head(adelie_torgersen)
```

```{r}
# Select penguins from Biscoe, Dream, OR Torgersen islands
three_islands <- filter(penguins, 
                        island == "Biscoe" | 
                        island == "Dream" | 
                        island == "Torgersen")

# A more concise way to write the same thing:
three_islands <- filter(penguins, 
                        island %in% c("Biscoe", "Dream", "Torgersen"))

head(three_islands)
```

**Common comparison operators:**
- `==` equals
- `!=` not equals
- `>` greater than
- `<` less than
- `>=` greater than or equal to
- `<=` less than or equal to

## Creating and Modifying Variables

Use `mutate()` to create new columns or modify existing ones:

```{r}
# Convert body mass from grams to kilograms
# Convert flipper length from mm to cm
penguins_converted <- mutate(penguins,
                              body_mass_kg = body_mass_g / 1000,
                              flipper_length_cm = flipper_length_mm / 10)

select(penguins_converted, species, body_mass_g, body_mass_kg, 
       flipper_length_mm, flipper_length_cm) %>%
  head()
```

### Recoding with `ifelse()`

The `ifelse()` function helps you create categorical variables based on conditions:

```{r}
# Create a size category based on body mass
penguins_sized <- mutate(penguins,
                         size = ifelse(body_mass_g > 4500,
                                      "large",
                                      "small"))

select(penguins_sized, species, body_mass_g, size) %>%
  head()
```

```{r}
# Create a new island variable with simplified names
penguins_recoded <- mutate(penguins,
                           island_short = ifelse(island %in% c("Biscoe", "Dream"),
                                                island,
                                                "Other"))

select(penguins_recoded, island, island_short) %>%
  head()
```

```{r}
# Set extreme values to missing (NA)
penguins_cleaned <- mutate(penguins,
                           bill_length_mm = ifelse(bill_length_mm < 30 | 
                                                   bill_length_mm > 60,
                                                   NA,
                                                   bill_length_mm))
```

## Summarizing Data

Use `summarize()` to calculate summary statistics. Combine it with `group_by()` to get statistics for each group:

```{r}
# Calculate overall mean flipper length and body mass
summary_stats <- summarize(penguins,
                          mean_flipper = mean(flipper_length_mm, na.rm = TRUE),
                          mean_mass = mean(body_mass_g, na.rm = TRUE))

summary_stats
```

**Note**: The `na.rm = TRUE` option tells R to ignore missing values when calculating means.

```{r}
# Calculate mean flipper length and body mass by species
species_summary <- penguins %>%
  group_by(species) %>%
  summarize(mean_flipper = mean(flipper_length_mm, na.rm = TRUE),
            mean_mass = mean(body_mass_g, na.rm = TRUE),
            count = n())

species_summary
```

```{r}
# Calculate statistics by species AND island
detailed_summary <- penguins %>%
  group_by(species, island) %>%
  summarize(mean_bill_length = mean(bill_length_mm, na.rm = TRUE),
            sd_bill_length = sd(bill_length_mm, na.rm = TRUE),
            count = n(),
            .groups = "drop")

detailed_summary
```

Many visualizations work best with summarized data rather than raw observations.

## Using the Pipe Operator

The pipe operator `%>%` (or `|>` in newer R versions) lets you chain operations together, making your code cleaner and easier to read:

```{r}
# Without pipes - harder to read
temp1 <- filter(penguins, species == "Adelie")
temp2 <- group_by(temp1, island)
result <- summarize(temp2, mean_mass = mean(body_mass_g, na.rm = TRUE))

result
```

```{r}
# With pipes - much clearer!
result <- penguins %>%
  filter(species == "Adelie") %>%
  group_by(island) %>%
  summarize(mean_mass = mean(body_mass_g, na.rm = TRUE))

result
```

The pipe takes the output from the left side and passes it as the first argument to the function on the right side.

## Working with Dates

Dates often come into R as text. The `lubridate` package makes it easy to convert them to proper date format:

```{r}
library(lubridate)

# Create a sample dataset with dates in various formats
sample_dates <- data.frame(
  person = c("Alice", "Bob", "Charlie"),
  birth_date = c("03/15/1995", "Jul-22-98", "1:10:2000")
)

# View the structure - dates are currently characters
str(sample_dates)
```

```{r}
# Convert to proper date format
sample_dates$birth_date <- mdy(sample_dates$birth_date)

# Now they're proper dates
str(sample_dates)
```

Common date conversion functions:
- `ymd()` for year-month-day format (2024-01-15)
- `mdy()` for month-day-year format (01/15/2024)
- `dmy()` for day-month-year format (15-01-2024)

Once converted, you can do date arithmetic and extract components:

```{r}
# Calculate age in years
sample_dates$age <- as.numeric(difftime(Sys.Date(), 
                                        sample_dates$birth_date, 
                                        units = "weeks")) / 52.25

sample_dates
```

## Reshaping Data: Wide vs. Long Format

Some analyses require data in "wide" format, others need "long" format.

**Wide format** (each measurement type gets its own column):

```{r}
# Create example wide data
wide_data <- data.frame(
  id = c("P01", "P02", "P03"),
  name = c("Alice", "Bob", "Charlie"),
  height_cm = c(165, 178, 172),
  weight_kg = c(62, 75, 70)
)

wide_data
```

**Long format** (all measurements in one column):

```{r}
library(tidyr)

# Convert wide to long
long_data <- pivot_longer(wide_data,
                          cols = c(height_cm, weight_kg),
                          names_to = "measurement",
                          values_to = "value")

long_data
```

**Converting back to wide:**

```{r}
# Convert long to wide
back_to_wide <- pivot_wider(long_data,
                            names_from = measurement,
                            values_from = value)

back_to_wide
```

Long format is often required for ggplot2, while wide format is easier for humans to read.

# Handling Missing Data

Real-world data usually contains missing values. There are three main approaches to dealing with them:

## Checking for Missing Values

First, see how much data is missing:

```{r}
# Count missing values in each column
colSums(is.na(penguins))
```

```{r}
# Calculate percentage missing
missing_pct <- colSums(is.na(penguins)) / nrow(penguins) * 100
round(missing_pct, 1)
```

## Approach 1: Remove Variables with Too Many Missing Values

If a variable has too many missing values (say, >50%), it might not be useful:

```{r}
# Remove columns with more than 5% missing data
threshold <- 0.05
missing_prop <- colSums(is.na(penguins)) / nrow(penguins)

penguins_cleaned <- penguins %>%
  select(where(~mean(is.na(.)) < threshold))

ncol(penguins)  # original number of columns
ncol(penguins_cleaned)  # after removal
```

## Approach 2: Listwise Deletion

Remove any rows that contain missing values:

```{r}
# Create dataset with only complete cases
penguins_complete <- penguins %>%
  select(species, bill_length_mm, bill_depth_mm, body_mass_g) %>%
  na.omit()

nrow(penguins)  # original rows
nrow(penguins_complete)  # after deletion
```

**Warning**: This can remove a lot of data if missingness is spread across many rows!

## Approach 3: Imputation

Imputation means replacing missing values with educated guesses. The `VIM` package offers sophisticated methods:

```{r}
#| eval: false
library(VIM)

# Impute missing values using k-nearest neighbors
penguins_imputed <- kNN(penguins, k = 5)
```

This method finds the 5 most similar complete cases and uses their median (for numeric variables) or most common value (for categorical variables) to fill in the missing data.

**Important**: Missing data can seriously bias your results. If you have substantial missing data, consult with a statistician before deciding how to handle it.

## Best Practices for Missing Data

1. **Investigate why data is missing** - Is it random or systematic?
2. **Document your decisions** - Always note how you handled missing values
3. **Compare methods** - Try multiple approaches and see how results differ
4. **Report missingness** - Tell readers how much data was missing

# Putting It All Together

Here's a complete workflow combining multiple operations:

```{r}
#| message: false
library(dplyr)
library(palmerpenguins)

# Complete data preparation pipeline
analysis_data <- penguins %>%
  # 1. Remove year column
  select(-year) %>%
  # 2. Keep only complete cases
  na.omit() %>%
  # 3. Filter to just two species
  filter(species %in% c("Adelie", "Gentoo")) %>%
  # 4. Create new variables
  mutate(
    bill_ratio = bill_length_mm / bill_depth_mm,
    size_category = ifelse(body_mass_g > 4500, "Large", "Small")
  ) %>%
  # 5. Group and summarize
  group_by(species, size_category) %>%
  summarize(
    avg_flipper = mean(flipper_length_mm),
    avg_mass = mean(body_mass_g),
    count = n(),
    .groups = "drop"
  )

analysis_data
```

# Summary

You've learned how to:

- Import data from CSV, text, Excel, and statistical software files
- Select specific columns and filter rows
- Create and recode variables
- Summarize data by groups
- Use pipes to chain operations together
- Work with dates
- Reshape data between wide and long formats
- Handle missing values appropriately

These data preparation skills form the foundation for all data analysis and visualization work in R.

# Practice Exercises

Try these exercises to reinforce your learning:

1. Load the `penguins` dataset and calculate the mean bill length for each species
2. Create a new variable called `bill_size` that categorizes bills as "short" (< 40mm) or "long" (≥ 40mm)
3. Find which island has the heaviest penguins on average
4. Remove all rows with missing sex values and count how many rows remain
5. Create a summary showing the count of penguins by species and sex

# Further Resources

- [R for Data Science](https://r4ds.had.co.nz/) - Comprehensive guide to data manipulation
- [dplyr documentation](https://dplyr.tidyverse.org/)
- [tidyr documentation](https://tidyr.tidyverse.org/)
- [Data Cleaning with R](https://cran.r-project.org/doc/contrib/de_Jonge+van_der_Loo-Introduction_to_data_cleaning_with_R.pdf)