---
title: "Visualizing Bivariate Data"
format: 
  html:
    fig-width: 12
    fig-height: 6
    code-fold: show
    code-tools: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    toc: true
    code-copy: true
    number_sections: true
    echo: fenced
---

One of the most fundamental questions in data analysis is: "How does variable A relate to variable B?"

Bivariate analysis allows us to investigate relationships, correlations, and differences between groups. The specific type of graph you choose depends entirely on the data types you are working with (Categorical or Quantitative).



# Categorical vs. Categorical

When both variables are categorical (e.g., "Species" and "Island"), we are essentially comparing counts or proportions. The most effective tools here are variants of the bar chart.

For this section, we will use the `penguins` dataset to explore the relationship between **Island** and **Species**.

## Stacked Bar Charts

The default behavior of a bar chart in `ggplot2` is to stack categories on top of one another. This gives you a sense of the total count while showing the breakdown of subgroups.

```{r Data Penguins}
#| echo: true 
#| message: false
#| warning: false

library(ggplot2)
library(palmerpenguins)

penguins <- palmerpenguins::penguins
penguins <- na.omit(penguins)

# Stacked bar chart
ggplot(penguins, aes(x = island, fill = species)) + 
  geom_bar(position = "stack") +
  labs(title = "Species Distribution by Island (Stacked)")

```

From this chart, we can quickly see that Biscoe island has the most penguins overall, and Torgersen island is exclusively inhabited by Adelie penguins.

## Grouped Bar Charts

If you want to compare the specific counts of species side-by-side, the "grouped bar chart is preferred. It un-stacks the bars and places them next to each other.

```{r Penguins 1}
#| echo: true 
#| message: false
#| warning: false

# Grouped bar chart
ggplot(penguins, aes(x = island, fill = species)) + 
  geom_bar(position = "dodge") +
  labs(title = "Species Distribution by Island (Grouped)")

```

:::{.callout-note}

By default, if a category has zero observations (like Chinstrap penguins on Biscoe), the bar is omitted, and the remaining bars expand to fill the space. If you want to preserve the width and show the gap, use `position_dodge(preserve = "single")`.

:::

## Segmented (100% Fill) Bar Charts

Sometimes, raw counts matter less than percentages. If we want to know "What proportion of penguins on Dream Island are Chinstraps?", we use the "fill" position. This stretches every bar to 100%.

```{r Penguins 2}
#| echo: true 
#| message: false
#| warning: false

library(scales)

# Segmented bar chart
ggplot(penguins, aes(x = island, fill = species)) + 
  geom_bar(position = "fill") + 
  scale_y_continuous(labels = percent) +
  labs(y = "Proportion", title = "Species Proportion by Island") +
  theme_minimal()

```

## Adding Labels

A segmented bar chart is most effective when the actual percentages are written on the plot. To do this, we must first calculate the percentages manually using `dplyr`, and then plot the summary data.

```{r Penguins 3}
#| echo: true 
#| message: false
#| warning: false

library(dplyr)

# 1. Create a summary table with labels
plotdata <- penguins %>%
  group_by(island, species) %>%
  summarize(n = n()) %>% 
  mutate(pct = n / sum(n),
         lbl = scales::percent(pct, accuracy = 1))

# 2. Plot using the summary data
ggplot(plotdata, aes(x = island, y = pct, fill = species)) + 
  # Use geom_col for pre-calculated data
  geom_col(position = "fill") + 
  geom_text(aes(label = lbl), 
            position = position_fill(vjust = 0.5), 
            color = "white", fontface = "bold") +
  scale_y_continuous(labels = percent) +
  labs(y = "Percent", title = "Species Composition by Island") +
  theme_minimal()
```

# Quantitative vs. Quantitative

When both variables are numeric (e.g., Flipper Length vs. Body Mass), we are looking for correlations or trends.

## Scatterplots

The scatterplot is the standard for bivariate quantitative data. Let's look at the relationship between **Flipper Length** and **Body Mass**.

```{r Penguins 4}
#| echo: true 
#| message: false
#| warning: false

# Scatterplot
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point(color = "cornflowerblue", size = 2, alpha = 0.6) + 
  labs(title = "Flipper Length vs. Body Mass",
       x = "Flipper Length (mm)",
       y = "Body Mass (g)") +
  theme_minimal()

```


## Time Series (Line Plots)

If one of your quantitative variables is **Time**, a line plot is the standard choice. Below is the change in Life Expectancy in the United States over time.

```{r}
#| echo: true 
#| message: false
#| warning: false

library(gapminder)
# Filter for US data
us_data <- filter(gapminder, country == "United States")

# Line plot with points
ggplot(us_data, aes(x = year, y = lifeExp)) + 
  geom_line(size = 1.2, color = "grey") + 
  geom_point(size = 3, color = "steelblue") + 
  labs(title = "US Life Expectancy (1952-2007)",
       y = "Life Expectancy (years)") +
  theme_minimal()

```

Times series are discussed in greater detail on the time series page.

# Categorical vs. Quantitative

This is perhaps the most common analysis type: comparing a numerical value across different groups.

## Bar Charts

We can plot the **Mean** of a variable for each group. Here, we calculate the average body mass for each penguin species.

```{r}
#| echo: true 
#| message: false
#| warning: false

# Calculate means
mean_data <- penguins %>%
  group_by(species) %>%
  summarize(mean_mass = mean(body_mass_g))

# Plot means
ggplot(mean_data, aes(x = species, y = mean_mass)) + 
  geom_col(fill = "steelblue", width = 0.7) + 
  geom_text(aes(label = round(mean_mass, 0)), vjust = -0.5) +
  scale_y_continuous(limits = c(0, 6000)) +
  labs(title = "Average Body Mass by Species", y = "Mass (g)") +
  theme_minimal()

```

:::{.callout-caution}

Bar charts of means can be misleading because they hide the spread of the data. A species with highly variable weights looks the same as a species with consistent weights.

:::


## Distributions: Boxplots and Violins

To see the spread, we use distribution plots.

### Boxplots

Boxplots summarize the distribution using quartiles. They show the median, the IQR (Interquartile Range), and outliers.

```{r}
#| echo: true 
#| message: false
#| warning: false

ggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) + 
  geom_boxplot(alpha = 0.6) + 
  labs(title = "Body Mass Distribution by Species") +
  theme_minimal() +
  theme(legend.position = "none")

```

### Violin Plots

Violin plots show the "density" of the data. The wider the violin, the more data points exist at that value.

```{r}
#| echo: true 
#| message: false
#| warning: false

ggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) + 
  geom_violin(trim = FALSE, alpha = 0.6) + 
  geom_boxplot(width = 0.1, fill = "white") + # Add boxplot inside for reference
  labs(title = "Violin Plot with Embedded Boxplot") +
  theme_minimal() +
  theme(legend.position = "none")

```

## Ridgeline Plots

Ridgeline plots (or "Joyplots") are excellent when you have many categories. They display density curves stacked vertically.

```{r}
#| echo: true 
#| message: false
#| warning: false

library(ggridges)

ggplot(penguins, aes(x = body_mass_g, y = species, fill = species)) + 
  geom_density_ridges(alpha = 0.7) + 
  labs(title = "Ridgeline Plot of Body Mass") +
  theme_ridges() + 
  theme(legend.position = "none")

```

## Mean with Error Bars

Scientific publications often require plots showing the Mean +/- the Standard Error (SEM) or Confidence Interval.

```{r}
#| echo: true 
#| message: false
#| warning: false

# Calculate stats
summary_stats <- penguins %>%
  group_by(species, sex) %>%
  summarize(
    n = n(),
    mean = mean(body_mass_g),
    sd = sd(body_mass_g),
    se = sd / sqrt(n)
  )

# Plot Mean +/- SE
pd <- position_dodge(0.2) # To separate overlapping bars

ggplot(summary_stats, aes(x = species, y = mean, color = sex, group = sex)) + 
  geom_point(position = pd, size = 4) + 
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0.2, position = pd, size = 1) +
  labs(title = "Mean Body Mass by Species and Sex",
       subtitle = "Error bars represent Standard Error",
       y = "Body Mass (g)") +
  theme_minimal()

```

## Jitter and Strip Plots

If your dataset isn't massive, the most honest way to show the data is to show **all** the points. To prevent points from overlapping, we "jitter" them (add random noise).

```{r}
#| echo: true 
#| message: false
#| warning: false

ggplot(penguins, aes(x = species, y = body_mass_g, color = species)) + 
  geom_jitter(width = 0.2, alpha = 0.6) + 
  stat_summary(fun = mean, geom = "point", shape = 95, size = 10, color = "black") + # Add mean bar
  labs(title = "Raw Data with Mean Indicator") +
  theme_minimal() +
  theme(legend.position = "none")

```

## Cleveland Dot Plots (Lollipop Charts)

When comparing a numeric value across many categories (like countries), a bar chart becomes cluttered. A Cleveland dot plot (or lollipop chart) is a cleaner alternative.

Let's look at Life Expectancy in the Americas in 2007.

```{r}
#| echo: true 
#| message: false
#| warning: false

# Prepare data
americas <- gapminder %>% 
  filter(continent == "Americas" & year == 2007)

# Lollipop Chart
ggplot(americas, aes(x = lifeExp, y = reorder(country, lifeExp))) + 
  geom_segment(aes(x = 60, xend = lifeExp, y = country, yend = country), color = "grey") +
  geom_point(size = 3, color = "darkcyan") + 
  labs(title = "Life Expectancy in the Americas (2007)",
       x = "Life Expectancy (Years)", y = "") +
  theme_minimal() +
  theme(panel.grid.major.y = element_blank()) # Remove horizontal grid lines for clarity

```

