---
title: "Newton–Raphson Method — Translating Math into Code"
format: 
  html:
    fig-width: 12
    fig-height: 6
    code-fold: show
    code-tools: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    toc: true
    code-copy: true
    number_sections: true
    echo: fenced
    mathjax: true
engine: knitr
---

# Mathematical Intuition

We want to find a root of ($f(x)=0$).\
We use the tangent line at ($x_n$) to estimate a better guess:

$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$. 

Repeat until ( $\|x_{n+1} - x_n\|$ ) is small.

```{r}
#| echo: false
#| warning: false
#| message: false

# Define function and derivative
f  <- function(x) x^3 - 2*x - 5
df <- function(x) 3*x^2 - 2

# Newton–Raphson iterations
newton <- function(x0, n) {
  x <- numeric(n + 1)
  x[1] <- x0
  for (i in 1:n) {
    x[i + 1] <- x[i] - f(x[i]) / df(x[i])
  }
  x
}

# Initial guess and iterations
x0 <- 2
iters <- newton(x0, 5)

# Plot function
curve(f, from = 1, to = 3, lwd = 2,
      ylab = "f(x)", xlab = "x",
      main = "Newton–Raphson Method")

abline(h = 0, col = "gray")

# Plot Newton steps
for (i in 1:5) {
  x_n <- iters[i]
  y_n <- f(x_n)
  slope <- df(x_n)
  
  # Tangent line
  abline(a = y_n - slope * x_n, b = slope,
         col = "steelblue", lty = 2)
  
  # Vertical drop to x-axis
  segments(x_n, y_n, iters[i + 1], 0,
           col = "firebrick")
  
  # Points
  points(x_n, y_n, pch = 16)
}

# Final root estimate
points(iters[6], 0, pch = 19, col = "firebrick")

```

------------------------------------------------------------------------

# Math → Algorithm → Code Mapping

| Math concept | R translation             |
|--------------|---------------------------|
| update rule  | `x_new <- x - f(x)/df(x)` |
| derivative   | function `df(x)`          |
| convergence  | `abs(x_new - x) < tol`    |

------------------------------------------------------------------------

```{mermaid}
%%| echo: false
%%| fig-align: center

flowchart TD
  Start([Start: choose x0, tol, max_iter])
  Compute["x_next with the algorithm"]
  Check{Is the absolute difference between <br/> the next guess x_next and <br/> the true root x less than the tolerance}
  Accept([Return x_next])
  Update["x <- x_next"]

  Start --> Compute --> Check
  Check -- Yes --> Accept
  Check -- No --> Update --> Compute
```

------------------------------------------------------------------------

# Implementation in R

```{r}
newton <- function(f, df, x0, tol = 1e-10, max_iter = 100) {
  x <- x0
  for (i in 1:max_iter) {
    fx <- f(x)
    dfx <- df(x)
    if (dfx == 0) stop("Derivative is zero; choose a new x0")
    x_new <- x - fx / dfx
    if (abs(x_new - x) < tol) return(x_new)
    x <- x_new
  }
  stop("Did not converge")
}

# Examples
f1 <- function(x) x^2 - 2
df1 <- function(x) 2*x
newton(f1, df1, x0 = 1)
```

------------------------------------------------------------------------

# Reflection

The Newton–Raphson method shows how an **iterative analytic idea** (tangent approximation) translates into a **computational fixed-point loop**.